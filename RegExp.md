# RegExp

## test()

- 检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，否则返回 false。
- /e/.test("The best things in life are free!") 返回true

## exec()

- 检索字符串中的正则表达式的匹配。该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。
- /e/.exec("The best things in life are free!"); 返回 ["e", index: 2, input: "The best things in life are free!"]

## 声明

- var regex = /^[0-9]+$/g; 这是正则表达式的字面量形式，类似于简写
- var regex = new RegExp("^[0-9]+$","g"); 这才是完整的定义正则表达式实例对象

## 修饰符

- /a/i 不区分大小写
- /a/g 全局匹配

## 元字符

- ^  匹配输入字符串的开始位置
- $  匹配输入字符串的结束位置
- \b 匹配一个单词边界，也就是指单词和空格间的位置。 例如， 'er\b' 可以匹配"never" 中的'er'，但不能匹配 "verb" 中的 'er'
- \B 匹配非单词边界。 'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'
- \w 字母或数字或下划线，等价于 [a-zA-Z0-9_]
- \W 非字母且非数字，等价于 [^A-Za-z0-9_]
- \n 匹配一个空格
- \s 匹配包括：空格，换行，回车，制表符，换页,等价于[ \n\r\t\f]
- \S 匹配非空格字符，等价于 [^ \f\n\r\t\v]
- \d 匹配10进制数字，等价于 [0-9]
- \D 匹配一个非数字字符。等价于 [^0-9]
- ?  当此字符紧随任何其他限定符（*、+、?、{n}、{n,}、{n,m}）之后时，匹配模式是“非贪心的”。在字符串“oooo”中，“o+?”只匹配单个“o”，而“o+”匹配所有“o”。
  - “000mp4  000 000mp4”中  “.+?mp4”只匹配“000mp4”，而“.+mp4”会匹配 “000mp4  000 000mp4”
- ? 用在要匹配的规则前是指断言，指要检测，但是不匹配的部分，即零宽断言
  - (?=exp)：零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp(匹配后面为exp)
    - `/(product)(?=_path)/` 可以匹配 `product_path`
  - (?<=exp):零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp(匹配前面为exp)
    - `/(?<=name:)(wang)/` 可以匹配 `name:wang`
  - (?!exp):零宽度负预测先行断言，断言此位置的后面不能匹配表达式exp(匹配后面不是exp)
    - `/(product)(?!_path)/` 可以匹配 `productpath`
  - (?<!exp):零宽度负回顾后发断言来断言此位置的前面不能匹配表达式exp(匹配前面不是exp)
    - `/(?<!name:)(wang)/` 可以匹配 `namewang`
- .  匹配除换行之外的任何单个字符。若要匹配包括换行在内的任意字符，请使用诸如“[\s\S]”之类的模式。
  - 单纯的只是匹配点号，加斜杠转义`\.`
- x|y 匹配 x 或 y 'z|food' 匹配“z”或“food”。'(z|f)ood' 匹配“zood”或“food”。
- /(['"]).+?\1/
  - \1 表示第一个括号匹配到的内容
  - 即匹配双引号或者单引号引起来的内容
  - 按左括号为序
  - $1 是在匹配结果替换表达式里用的
  - \1是在正则里用的

```js
(aaa(vvv(ccc)))(ddd)
$1 = aaavvvccc
$2 = vvvccc
$3 = ccc
$4 = ddd
```

## 匹配时需要 \ 转义的字符

- $ ( ) [ ] { } * + . ? \ ^ | /

## 量词

- n* 匹配任何包含零个或多个 n 的字符串，等效于 {0,}
- n+ 匹配任何包含至少一个 n 的字符串，等效于 {1,}
- n? 匹配任何包含零个或一个 n 的字符串，等效于 {0,1}

## 表达式

- [abc] 查找方括号之间的任何字符
- [^abc] 脱字符^ 匹配未包含的任何字符
- a{n} 正好匹配 n 次才行
- a{n,m} 匹配n ~ m次，在这之间都行。“o{1,3}”匹配“fooooood”中的头三个 o
- a{n,} 至少匹配 n 次
- a{,m} 至多匹配 m 次