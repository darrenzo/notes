# Web 缓存（http 缓存）

- [参考文档](https://www.oschina.net/translate/cache_docs)
- 表述：HTML 页面、图片和文件等的统称
- Web 缓存处于服务器（也称为源服务器）和客户端之间，监视请求并保存响应的表述的副本。如果之后有对同一个 URL 的新请求，它会使用自己保存的内容来响应，而不是再次请求源服务器来获取内容
- 代理和浏览器缓存默认都会被使用在某个环节中。如果你没有正确的配置站点的缓存相关配置，站点数据将会按照默认的缓存管理员的配置被缓存下来
- 作用：
  - 减少延迟：因为响应请求的内容来自缓存（距客户端较近）而不是源服务器，它会花较少的时间来获得表述并将他们呈现出来，这使得 Web 看起来具有良好的响应速度
  - 减少网络传输：由于复用了表述，它可以减少客户端使用的带宽总量。缓存会降低对带宽的要求，也降低处理难度
  
## 缓存种类

### 浏览器缓存

- 浏览器“缓存”设置：这个选项让你配置一部分硬盘空间来保存你看过的表述
- 浏览器缓存的规则：它通常会在一次会话（即当前浏览器中第一次调用）中检查表述是否最新
- 这个缓存在用户使用“回退”按钮或者点击一个浏览过的链接时会特别有用
- 如果你在网站的各个页面中浏览相同的图片，他们几乎能马上从缓存中加载出来
  
### 代理缓存

- 应用于同一种协议间的传输
- 规模比浏览器缓存更大，代理以同样的方式为成百上千的用户服务
- 大公司和 ISP 常常把代码缓存建立在防火墙之上，也可能是以独立设备的形式存在（也称为中间设备）
- 代理缓存即不是客户端的一部分，也不是服务器的一部分，而是在网络之外，必须以某种方式把请求路由过去
  - 方式一：手工修改浏览器代理设备，指定要使用的代码
  - 方式二：拦截。拦截式代理会根据其自身的基础网络重定向 Web 请求，不需要在客户端配置，客户端甚至不知道它们的存在
- 代理缓存是一种共享缓存，通常不只是一个用户，而是大量用户在使用代理缓存，众人都需要的表述会被多次重复使用
- 隧道：代理的一种延伸，对一种协议进行加密传输，比如vpn。目前协议传输较少用代理进行传输，隧道安全性高，所以较多使用
  
### 网关缓存

- 对不同协议进行转换传输
- 又名“反向代理缓存”或“替代缓存”
- 网关缓存也是一种中介，由网站管理员自己部署，使其站点更具伸缩性、可靠性以及拥有更好的性能
- 常见的方法是使用负载均衡器把请求路由到网关缓存，让他们对于客户来说，看起来就跟源服务器一样
- 内容分发网络（CDN）在整个 Internet（或它的一部分）中分发网关缓存，并将其出售给对此感兴趣的网站

## 缓存工作方式

- 所有的缓存都有一系列用来决定什么时候从缓存中提供内容的规则
- 其中的一些规则被放置在了协议中（HTTP 1.0和1.1），而另一些则由缓存的管理员（诸如浏览器缓存的用户，或者代理管理员）来设置
- 规则集
  - 如果响应的头部通知缓存不要保存当前响应内容，那么缓存就不会缓存当前响应。
  - 如果是一个授权的或者加密的请求（例如HTTPS），那么共享缓存将不会保存相关数据内容。
  - 在下述场景中，我们认为被缓存的内容是最新的（意味着不需要源服务端的检查就可以被发送给客户端），故而数据内容会直接从缓存中提供且不需要源服务端的校验
    - 缓存内容由过期时间或者其他的生存期控制机制，且缓存内容仍在生存有效期内
    - 如果缓存服务近期对外提供了数据内容，且该内容在很久之前就被修改了
  - 如果内容已经过时了，源服务端会要求对其进行验证，或者通知缓存服务这份缓存的内容是否仍然有效
  - 在类似于网络中断这样的场景中，缓存可以对外提供过时的响应数据而不必和源服务器进行校验和确认
- 如果在响应中没有相应的验证器（ ETag 或者 Last-Modified 头部），且也没有明确的刷新信息，则这种数据通常被视为不可缓存的数据（但不总是）
- 刷新和验证是缓存可以正常有效的保存内容的最重要途径。新的数据内容可以快速的从缓存中得到，与此同时一个经过验证的表述则避免了在没有发生变更的情况下被再次完整的发送出去

## 缓存控制

### HTML Meta 标签

- meta 标签常用于确保文档不被缓存，或者在一定时间后过期。但效果不怎么样
- 只有部分浏览器缓存会遵从约定，代理缓存却不会（代理基本上不会去分析文档中的 HTML）

### Pragma HTTP 头

- 存在响应头中
- 指定 Pragma: no-cache HTTP 头不一定可以避免表述被缓存
  - 不是指的Cache-Control HTTP 头的 no-cache

### Expires HTTP 头控制新近程度

- 存在响应头中
- Expires HTTP 头是控制缓存的基础方法，它告诉所有缓存与之相关的表述存在多久的保鲜期
- 保鲜期之后，缓存应该检查源服务器，看文档是否被改变。几乎各种缓存都支持 Expires 头
- 设置方法：
  - 设置绝对的过期时间，根据上次客户端取回表述时（最近访问时间）计算的时间
  - 根据上次服务器文档修改时间计算的时间（最近修改时间）
- Expires 头特别适合缓存静态图像（比如导航栏和按钮），因为他们不会经常变化，你可以为他们设置一个非常长的过期时间，使你的站点具有更优势的响应性能
- 根据页面信息更新规律设置缓存更新时长和时间点
- Expires 头只支持 HTTP 日期值，任何其它值都会被认为“过去时”，结果表述不会被缓存
- HTTP 日期是格林威治（GMT）时间，而不是本地时间。如 Expires: Fri, 30 Oct 1998 14:19:41 GMT
- 局限：
  - Web 服务器和缓存上的时钟就必须同步
  - 必须保证服务器时钟的准确性
  - 可以使用网络时间协议（NTP）
  - 容易忘记为某些内容设置了特定的过期时间
  
### Cache-Control HTTP 头

- 当 Cache-Control 和 Expires 都存在时，Cache-Control 优先
- Cache-Control 响应头，让 Web 可以更方便地控制内容，避免 Expires 所具有的限制
- 属性
  - max-age=[秒] — 指定表述内容的最大有效期。跟 Expires 类似，这个指令的时间是相对于请求时间，而不是绝对时间。[秒] 是从请求开始你期望表述过期前保持有效的总秒数
  - s-maxage=[秒] — 和 max-age 相似，但它只对共享（例如代理）缓存有效
  - public — 把通过认证的响应标记为可缓存。一般情况下，如果需要 HTTP 认证，响应会自动标记为私有的
  - private — 允许用户（比如一个浏览器）缓存响应，不允许共享缓存（比如代理）进行缓存
  - no-cache — 强制缓存将请求提交到原服务器进行验证后释放缓存副本，一次不落。这可以确保谨慎地对待认证（结合 public 标记），严谨地更新，同时又不牺牲缓存所带来的各种好处
  - no-store — 指示缓存在任何情况下都不保留表述的副本
  - must-revalidate — 告诉缓存，他们必须遵守你给他们关于内容更新的每一项信息。HTTP 允许缓存服务在一些特殊情况下认为表述过期，你可以通过指定这个头参数告诉缓存你希望它严格遵守你的规则
  - proxy-revalidate — 与 must-revalidate 相似，但它只对代理缓存有效
  - 如：Cache-Control: max-age=3600, must-revalidate

### 校验器和校验

- 存在响应头中
- 在表示层发生变化时服务器和缓存使用校验进行通信
- 通过使用校验，缓存可以避免在本地已有副本时下载整个表示层。当他们不确定它是否仍然是最新的，所以需要校验器去校验
- 如果校验器不存在，并且没有任何新的信息（ Expires 或 Cache-Control ）可用，则缓存将根本不存储表示层
- 常用校验器
  - Last-Modified：最通用的校验器是头部的 Last-Modified，用来标识文档最近一次修改的时间
    - 如果缓存存储了一个带有Last-Modified 头部的表示层，缓存可以借助一个 If-Modified-Since 请求向服务端确认当前缓存的表示层在最近一次修改后是否发生了变更
  - ETag：ETags是一个由服务端生成的唯一标识符，并且每当表示层发生变更时ETags的值都会发生变化
    - 由于ETag是由服务端生成的，所以当缓存通过 If-None-Match 请求得知ETag在服务端匹配成功时，便可以确认缓存存储的表示层和服务端的内容是一致的，没有发生任何变化
- 几乎所有的缓存都使用了最近一次修改时间来作为校验器，同时ETag校验器的使用也在逐步增长
  - 大多数的现代网站服务器会自动地为静态内容（例如文件）同时生成 ETag 和 Last-Modified 这两个校验器，这个过程不需要任何人为参与。然而，服务器在为诸如CGI、ASP或者数据库站点这样的动态内容生成ETag 和 Last-Modified 校验器时就显得力不从心了

### 构建缓存感知站点的技巧

- 除了以上使用新鲜度信息和校验，以下方法值得参考
  - 始终使用url：如果向不同的页面、不同的用户提供同样的数据内容，或者同样的内容来自于不同的站点，这时应该使用一致的URL
    - 缓存的黄金原则
    - 最简单、最有效的让站点更利于缓存的方法
  - 使用一个包含图片和其他元素的公共库，并在不同的地方引用他们
  - 使用缓存来存储图片和很少变更的页面
    - 这个的实现可以借助一个设置了很大的值的 Cache-Control: max-age 头部信息
  - 通过一个精确的最大存活时间或者过期时间让缓存识别出更新频繁的页面
  - 如果资源（特别是可下载的文件）发生了变更，改变其名字
    - 通过这种方式，可以让资源在未来的某个时间过期，同时也能保证当前版本仍然是有效的。唯一需要设置一个短的过期时间的部分就是链接到这些资源的页面
  - 在必要的情况下再修改文件
    - 如果非必要的情况下也选择更新文件，那么每个文件都会有一个不真实的距离当前时间更近的 Last-Modified 值。
    - 例如当准备更新站点时，不要复制整个站点文件进行更新，仅选择那些确实修改了的文件去执行更新操作
  - 只在有需要的情况下使用cookie
    - cookies很难被缓存存储起来，并且在大多数场景都是没有必要的
    - 如果必须用到cookie的话，那么也只在动态页面中使用cookie

## 编写缓存可感知的脚本

- 如果脚本生成的输出在以后的某个时间（无论是几分钟还是几天后）都可以使用相同的请求重现，那么它应该是可缓存的
- 如果脚本的内容仅根据 URL 中的内容而变动，则它是可缓存的
- 如果其输出取决于cookie、身份认证信息或其他外部标准，则它可能不是可缓存的
- 技巧：
  - 让脚本对缓存友好（同时有更好的表现）的最佳方式是只要脚本发生变化，就将其内容转储到一个普通文件中
    - Web 服务器会把这个文件跟其它 Web 页面同等对待，为其生成验证器，让一切变得简单
    - 只写内容变动过的文件，避免刷新新没有内容变动文件的 Last-Modified 时间
  - 设置一个跟寿命相关的头，可以让脚本在一定的限制条件下被缓存。
    - 虽然用 Expires 可以做到，但用 Cache-Control: max-age 可能更简单，它会按一定时间间隔刷新请求
  - 用脚本生成一个验证器，然后响应 If-Modified-Since 或 If-None-Match 请求
    - 这个操作可以通过解析 HTTP 头之后，适当的响应 304 Not Modified 来实现
  - 不使用 POST，除非确有必要
    - 多数缓存不会保存 POST 响应。如果你通过路径或查询（通过 GET）发送信息，缓存会保存这些信息以备将来使用
  - 不要在 URL 中嵌入用户特定的信息，除非生成的内容对每个用户都不同
  - 不要以为所有用户请求都来自同一台主机，因为也有可能来自缓存
  - 生成 Content-Length 响应头，它会允许通过长连接来响应脚本
    - 客户端可以在一个 TCP/IP 连接上请求多个表述，而不是为每个请求建立连接。这样网站看起来会更快