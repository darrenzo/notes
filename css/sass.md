# sass

- [官网](http://sass-lang.com/)
- 样式库[Compass](http://compass-style.org/)
- [函数](http://sass-lang.com/documentation/Sass/Script/Functions.html)
- 启用vscode自带的stylelint检查工具
- 启用gulp-sass自动化工具

## 特点

- 完全兼容 CSS3
- 在 CSS 基础上增加变量、嵌套 (nesting)、混合 (mixins) 等功能
- 通过函数进行颜色值与属性值的运算
- 提供控制指令 (control directives)等高级功能
- 自定义输出格式

## 安装

### ruby安装法

- 因为sass是以ruby语言为基础，所以得去[ruby官网](https://rubyinstaller.org/)下载
- 安装ruby需要勾选`add Ruby executables to your PATH`
- `ruby -v`检查是否安装成功
- ruby安装包中集成了gem包管理工具
- 放在rubygem.org上的资源文件位于国外站点,所以要先把gem的连接源改到国内的一些镜像资源上
- `gem sources --remove https://rubygems.org/` 取消默认的绑定源
- `gem sources -a http://gems.ruby-china.org/` 绑定国内网站
- `gem sources -l` 查看current resources, 以验证换源是否成功
- gem install sass
- sass -v

### npm安装法

- npm install -g sass
  
## 编译

- 编译scss文件为css文件
  - sass input.scss output.css
- 自动监视并编译scss文件为css文件
  - sass --watch input.scss output.css
  - sass --watch app/sass:public/stylesheets

## 语法格式

- Sass 有两种语法格式
  - Sass (Indented Sass): 最早的 Sass 语法格式, 它使用 “缩进” 代替 “花括号” 表示属性属于某个选择器，用 “换行” 代替 “分号” 分隔属性, 这种格式以 .sass 作为拓展名
  - Scss (Sassy CSS)：这种格式仅在 CSS3 语法的基础上进行拓展，这种格式以 .scss 作为拓展名。(常用)
- 任何一种格式可以直接 导入 (@import) 到另一种格式中使用，或者通过 sass-convert 命令行工具转换成另一种格式

```shell
# Convert Sass to SCSS
$ sass-convert style.sass style.scss

# Convert SCSS to Sass
$ sass-convert style.scss style.sass
```

## 输出格式

- Sass 提供了四种输出格式，可以通过 :style option 选项设定，或者在命令行中使用 --style 选项
  - :nested （嵌套）样式是 Sass 默认的输出格式 ( npm安装后只有[expanded (default), compressed]选项 )

  ```css
  #main {
    color: #fff;
    background-color: #000; }
    #main p {
      width: 10em; }

  .huge {
    font-size: 10em;
    font-weight: bold;
    text-decoration: underline; }
  ```

  - :expanded

  ```css
  #main {
    color: #fff;
    background-color: #000;
  }
  #main p {
    width: 10em;
  }

  .huge {
    font-size: 10em;
    font-weight: bold;
    text-decoration: underline;
  }
  ```

  - :compact

  ```css
  #main { color: #fff; background-color: #000; }
  #main p { width: 10em; }

  .huge { font-size: 10em; font-weight: bold; text-decoration: underline; }
  ```

  - :compressed

  ```css
  #main{color:#fff;background-color:#000}#main p{width:10em}.huge{font-size:10em;font-weight:bold;text-decoration:underline}
  ```

## 嵌套

```scss
    #header {
      color: black;
      .navigation {
          font-size: 12px;
      }
    }
```

## 父选择器 &

- & 必须作为选择器的第一个字符，其后可以跟随后缀生成复合的选择器

```scss
    #main {
      color: black;
      &:hover {
          color: red;
      }
      &-sidebar { border: 1px solid; }
    }
```

`output`

```css
  #main {
    color: black;
  }
  #main:hover {
    color: red;
  }
  #main-sidebar {
    border: 1px solid;
  }
```

- 如果没有父选择器，&的值将为null。这可以在mixin中使用它来检测父选择器是否存在

```scss
@mixin does-parent-exist {
  @if & {
    &:hover {
      color: red;
    }
  } @else {
    a {
      color: red;
    }
  }
}

.page-title {
  @include does-parent-exist;
}
```

## 属性嵌套

- font 作为`font-family, font-weight`属性的命名空间

```scss
    .funky {
      font: 20px/24px {
        family: fantasy;
        weight: bold;
      }
    }
```

`output`

```css
    .funky {
      font: 20px/24px;
      font-family: fantasy;
      font-weight: bold;
    }
```

## 注释

- 多行注释 /* */： 会被完整输出到编译后的 CSS 文件中
- 单行注释：不会被完整输出到编译后的 CSS 文件中
- 将 ! 作为多行注释的第一个字符表示在压缩输出模式下保留这条注释并输出到 CSS 文件中，通常用于添加版权信息
- 插值语句 (interpolation) 也可写进多行注释中输出变量值

```scss
$version: "1.2.3";
/* This CSS is generated by My Snazzy Framework version #{$version}. */
```

`output`

```css
/* This CSS is generated by My Snazzy Framework version 1.2.3. */
```

## SassScript

- 在 CSS 属性的基础上 Sass 提供了一些名为 SassScript 的新功能
- 在命令行中输入 sass -i, 然后输入想要测试的 SassScript 查看输出结果

```shell
>> 1px + 1px + 1px
3px
>> #777 + #777
#eeeeee
>> #777 + #888
white
```

## 变量 $

```scss
$width: 5em;
#main {
  width: $width;
}
```

- 变量支持块级作用域
- 嵌套规则内定义的变量只能在嵌套规则内使用（局部变量）
- 不在嵌套规则内定义的变量则可在任何地方使用（全局变量）
- 将局部变量转换为全局变量可以添加 !global 声明

```scss
#main {
  $width: 5em !global;
  width: $width;
}

#sidebar {
  width: $width;
}
```

`output`

```css
#main {
  width: 5em;
}

#sidebar {
  width: 5em;
}
```

### 变量默认定义 !default

- 可以在变量的结尾添加 !default，如果在此之前变量已经赋值，那就不使用默认值，如果没有赋值，则使用默认值
- 变量是 null 空值时将视为未被 !default 赋值
- 可以设置在任意地方，如果同一个变量有多个!default，只有第一个会生效

```less
/* 如果之前已经赋值,则不再使用默认值 */
$const: "Hi";
$const: "hello" !default;

div{
    const: $const;
}

//output
div {
  const: "Hi";
}
```

### 插值语句 #{}

- 通过 #{} 插值语句可以在选择器或属性名中使用变量
- 使用 #{} 可以避免 Sass 运行运算表达式，直接编译 CSS

```scss
$name: foo;
$attr: border;
p.#{$name} {
  #{$attr}-color: blue;
}
```

## 数据类型（6种）

- 数字： 13, 10px
- 字符串，有引号字符串与无引号字符串，"foo", 'bar', baz
- 颜色，blue, #04a3f9, rgba(255,0,0,0.5)
- 布尔型，true, false
- 空值，null
- 数组 (list)，用空格或逗号作分隔符，1.5em 1em 0 2em, Helvetica, Arial, sans-serif
- maps, 相当于 JavaScript 的 object，(key1: value1, key2: value2)

### 字符串

- 对于有引号和无引号的字符串，编译css文件时除了使用`#{}`插值以外，都不会改变其类型
- #{} (interpolation) 时，有引号字符串将被编译为无引号字符串，这样便于在 mixin 中引用选择器名

```scss
@mixin firefox-message($selector) {
  body.firefox #{$selector}:before {
    content: "Hi, Firefox users!";
  }
}
@include firefox-message(".header");
```

`output`

```css
body.firefox .header:before {
  content: "Hi, Firefox users!";
}
```

### 数组(list)

- 通过空格或者逗号分隔的一系列的值组成list
- 独立的值也被视为数组 —— 只包含一个值的数组
- nth 函数可以直接访问数组中的某一项
- join 函数可以将多个数组连接在一起
- append 函数可以在数组中添加新值
- @each 指令能够遍历数组中的每一项
- 数组中可以包含子数组
  - `1px 2px, 5px 6px` 是包含 `1px 2px` 与 `5px 6px` 两个数组的数组
  - 如果内外两层数组使用相同的分隔方式，需要用圆括号包裹内层
    - `(1px 2px) (5px 6px)` 是使用空格分割的两个数组
- 当数组被编译为 CSS 时，Sass 不会添加任何圆括号
  - `(1px 2px) (5px 6px)` 与 `1px 2px, 5px 6px` 在编译后的 CSS 文件中是完全一样的, 但是它们在 Sass 文件中却有不同的意义，前者是包含两个数组的数组，而后者是包含四个值的数组
- 用 () 表示不包含任何值的空数组,也可以表示为空的map
- 空数组不可以直接编译成 CSS,有时候会报错
  - 如果数组中包含空数组或空值，编译时将被清除，比如 `1px 2px () 3px` 或 `1px 2px null 3px`
- 基于逗号分隔的数组允许保留结尾的逗号，这样做的意义是强调数组的结构关系，尤其是需要声明只包含单个值的数组时
  - `(1,)` 表示只包含 1 的数组
  - `(1 2 3,)` 表示包含 1 2 3 这个以空格分隔的数组 的数组

### Maps

- map-get函数在映射中查找值
- map-merge函数向映射添加值
- @each指令可用于为映射中的每个键/值对添加样式
- map中键值对的顺序始终与创建map时相同
- 当map被list函数使用时，它被视为键值对的列表。`(key1: value1, key2: value2)` 被看成  `key1 value1, key2 value2`, 例如使用`@each`对map进行遍历时
- 但是除了空列表之外，列表不能被视为map。()表示没有键/值对的map和没有元素的列表。
- 不能将map转换为纯CSS。使用inspect($value)函数生成用于调试map的输出字符串

```scss
$map: (key1: value1, key2: value2, key3: value3);
```

### 颜色

- rgb()和rgba()可以直接接受十六进制颜色
- `rgba(#f36,.5)` 转成 `rgba(255, 51, 102, 0.5)`

### 运算

- 类似less运算规则
- 需要确保 `/` 符号不被当成除法运算符，则需要给值加上插值#{}
- 颜色运算：alpha不加入运算，所以如果是带alpha值的颜色运算，需要保证alpha一致
- 运算表达式与其他值连用时，用空格做连接符 `p { margin: 3px + 4px auto; }`
- 空的值被视作插入了空字符串

```scss
$value: null;
p:before {
  content: "I ate #{$value} pies!";
}
```

`output`

```css
p:before { content: "I ate pies!"; }
```

- SassScript 支持布尔型的 and or 以及 not 运算。
- SassScript 不支持任何list运算方式,只能使用 list functions 控制。

## @-Rules 与指令

### @import

- @import 的功能，允许其导入 SCSS 或 Sass 文件。被导入的文件将合并编译到同一个 CSS 文件中，另外，被导入的文件中所包含的变量或者混合指令 (mixin) 都可以在导入的文件中使用
- 在以下情况下，@import 仅作为普通的 CSS 语句，不会导入任何 Sass 文件
  - 文件拓展名是 .css
  - 文件名以 `http://`开头
  - 文件名是 url()
  - @import 包含 media queries
- 没有指定拓展名，Sass 将会试着寻找文件名相同，拓展名为 .scss 或 .sass 的文件并将其导入
- Sass 允许同时导入多个文件  `@import "rounded-corners", "text-shadow";`
- 导入文件也可以使用 #{ } 插值语句，但不是通过变量动态导入 Sass 文件，只能作用于 CSS 的 url() 导入方式

```scss
$family: unquote("Droid+Sans");
@import url("http://fonts.googleapis.com/css?family=\#{$family}");
```

`output`

```css
@import url("http://fonts.googleapis.com/css?family=Droid+Sans");
```

- 如果需要导入 SCSS 或者 Sass 文件，但又不希望将其编译为 CSS，只需要在文件名前添加下划线  `@import "_colors";`
- 不可以同时存在添加下划线与未添加下划线的同名文件，添加下划线的文件将会被忽略。
- 嵌套 @import: 以将 @import 嵌套进 CSS 样式或者 @media 中, 这样导入的样式只能出现在嵌套的层中
- 不可以在混合指令 (mixin) 或控制指令 (control directives) 中嵌套 @import

### @media嵌套

```scss
.sidebar {
  width: 300px;
  @media screen and (orientation: landscape) {
    width: 500px;
  }
}
```

`output`

```css
.sidebar {
    width: 300px;
}
@media screen and (orientation: landscape) {
    .sidebar {
        width: 500px;
    }
}
```

- 自动补`and`

```scss
@media screen {
  .sidebar {
    @media (orientation: landscape) {
      width: 500px;
    }
  }
}
```

`output`

```css
@media screen and (orientation: landscape) {
    .sidebar {
        width: 500px;
    }
}
```

- @media 可以使用 SassScript（比如变量，函数，以及运算符）代替条件的名称或者值

### @extend (不推荐，容易破坏代码结构，只推荐用@mixin，用%占位符也比较好)

- Sass 将一个选择器下的所有样式继承给另一个选择器

```scss
.error {
  border: 1px #f00;
  background-color: #fdd;
}
// 其他使用到 .error 的样式也会同样继承给 .seriousError
.error.intrusion {
  background-image: url("/image/hacked.png");
}
.seriousError {
  @extend .error;
  border-width: 3px;
}
```

`output`

```css
.error,
.seriousError {
  border: 1px #f00;
  background-color: #fdd;
}

.error.intrusion,
.seriousError.intrusion {
  background-image: url("/image/hacked.png");
}

.seriousError {
  border-width: 3px;
}
```

- Sass 不再允许延伸任何定义给复合选择器, 比如 `.special.cool`，`a:hover` 或者 `a.user[href^="http://"]` 等，都应该使用多重延伸，否则报错。

- 多重延伸
  - `@extend .error, .attention;` 与 `@extend .error; @extend.attention` 有相同的效果

```scss
.error {
  border: 1px #f00;
  background-color: #fdd;
}
.attention {
  font-size: 3em;
  background-color: #ff0;
}
.seriousError {
  @extend .error;
  @extend .attention;
  border-width: 3px;
}
```

- 继续延伸
  - 当一个选择器延伸给第二个后，可以继续将第二个选择器延伸给第三个

```scss
.error {
  background-color: #fdd;
}
.seriousError {
  @extend .error;
  border-width: 3px;
}
.criticalError {
  @extend .seriousError;
  position: fixed;
}
```

- 选择器列
  - 暂时不可以将选择器列, 比如 `.foo .bar` 或 `.foo + .bar`，延伸给其他元素，但是，却可以将其他元素延伸给选择器列

```scss
#fake-links .link {
  @extend a;
}

a {
  color: blue;
  &:hover {
    text-decoration: underline;
  }
}
```

- 合并选择器列 (避免)
  - 选择器列中的某个元素需要延伸给另一个选择器列，这时两个选择器列需要合并
  - Sass 只会编译输出有用的选择器
  - 两个列合并时，如果没有包含相同的选择器，将生成两个新选择器

```scss
#admin .tabbar a {
  font-weight: bold;
}

#demo .overview .fakelink {
  // 会和所有有a标签样式的选择器列一一合并
  @extend a;
}
```

`output`

```css
#admin .tabbar a,
#admin .tabbar #demo .overview .fakelink,
#demo .overview #admin .tabbar .fakelink {
  font-weight: bold;
}
```

- 两个列 (sequence) 包含了相同的选择器，相同部分将会合并在一起，其他部分交替输出

```scss
#admin .tabbar a {
  font-weight: bold;
}
#admin .overview .fakelink {
  @extend a;
}
```

`output`

```css
#admin .tabbar a,
#admin .tabbar .overview .fakelink,
#admin .overview .tabbar .fakelink {
  font-weight: bold;
}
```

### @extend-Only 选择器 (%占位符)

- 需要定义一套样式并不是给某个元素用，而是只通过 @extend 指令使用，尤其是在制作 Sass 样式库的时候，希望 Sass 能够忽略用不到的样式
- 当它们单独使用时，不会被编译到 CSS 文件中
- 看起来很像普通的 id 或 class 选择器，只是 # 或 . 被替换成了 %

```scss
#context a%extreme {
  color: blue;
  font-weight: bold;
  font-size: 2em;
}

%single {
  border: 1px solid #000;
}

.notice {
  @extend %extreme;
  @extend %single;
  background: #fff;
}
```

`output`

```css
#context a.notice {
  color: blue;
  font-weight: bold;
  font-size: 2em;
}

.notice {
  border: 1px solid #000;
}

.notice {
  background: #fff;
}
```

### !optional 声明

- @extend 失败会收到错误提示

```scss
// 当没有`.notice`选择器时会报错
a.important {
  @extend .notice;
}
```

- 如果要求 @extend 不报错提示，可以使用 !optional 声明

```scss
a.important {
  @extend .notice !optional;
}
```

### 在指令中延伸

- 在指令中使用 @extend 时（比如在 @media 中）有一些限制：Sass 不可以将 @media 层外的 CSS 规则延伸给指令层内的 CSS
- 如果在 @media （或者其他 CSS 指令）中使用 @extend，必须延伸给相同指令层中的选择器

```scss
// 可行
@media print {
  .error {
    border: 1px #f00;
  }
  .seriousError {
    @extend .error;
    border-width: 3px;
  }
}

// 不可行
.error {
  border: 1px #f00;
}

@media print {
  .seriousError {
    @extend .error;
    border-width: 3px;
  }
}
```

### @at-root

- 该指令使一个或多个规则在文档的根发出，而不是嵌套在它们的父选择器下面

```scss
.parent {
  color: #000;
  @at-root .child {
    color: #fff;
  }
}

.parent1 {
  color: #fff;
  @at-root {
    .child1 {
      color: #000;
    }
    .child2 {
      color: #000;
    }
  }
  .step-child {
    color: #fff;
  }
}
```

`output`

```css
.parent {
  color: #000;
}
.child {
  color: #fff;
}

.parent1 {
  color: #fff;
}
.child1 {
  color: #000;
}

.child2 {
  color: #000;
}

.parent1 .step-child {
  color: #fff;
}
```

### @at-root (without: ...) and @at-root (with: ...)

- 默认情况下`@at-root`只排除选择器，不会把规则移到指令外部。但也可以使用@at-root将@media等嵌套指令移出
- `@at-root (without: media supports)` 可以移动到media和supports外部
- `@at-root (without: rule)` 表示移到所有指令外部
- `@at-root` 指移到所有css规则外部
- `@at-root (without: all)`意味着样式应该移动到所有指令和CSS规则之外

```scss
@media print {
  .page {
    width: 8in;
    @at-root (without: media) {
      color: red;
    }
    @at-root (without: media) {
      .sin {
        color: #000;
      }
    }
  }
}
```

`output`

```css
@media print {
  .page {
    width: 8in;
  }
}

/* 注意此时会有父元素 */
.page {
  color: red;
}

/* 注意此时会有父元素 */
.page .sin {
  color: #000;
}
```

- `@at-root (with: ...)` 指定要包含哪些指令或规则

## @debug

- 将SassScript表达式的值打印到标准错误输出流

```scss
@debug 10em + 12em;
```

`output`

```shell
input.scss:8 DEBUG: 22em
```

## @warn

- 将SassScript表达式的值打印到标准错误输出流
- 可以使用--quiet命令行选项或:quiet Sass选项关闭警告
- 样式表跟踪将与消息一起输出，以便被警告的用户可以看到他们的样式在哪里引起警告

```scss
@mixin adjust-location($x, $y) {
  @if unitless($x) {
    @warn "Assuming #{$x} to be in pixels";
    $x: 1px * $x;
  }
  @if unitless($y) {
    @warn "Assuming #{$y} to be in pixels";
    $y: 1px * $y;
  }
  position: relative; left: $x; top: $y;
}
```

## @error

- 将SassScript表达式的值作为一个致命错误抛出，包括一个堆栈跟踪
- 通常用于验证mixin和函数的参数
- 目前没办法捕捉错误

```scss
@mixin adjust-location($x, $y) {
  @if unitless($x) {
    @error "$x may not be unitless, was #{$x}.";
  }
  @if unitless($y) {
    @error "$y may not be unitless, was #{$y}.";
  }
  position: relative; left: $x; top: $y;
}
```

## 控制指令

- 日常编写过程中并不常用到，主要与混合指令 (mixin) 配合使用，尤其是用在 Compass 等样式库中

### @if

- 当 @if 的表达式返回值不是 false 或者 null 时，条件成立，输出 {} 内的代码

```scss
$type: monster;
p {
  @if $type == ocean {
    color: blue;
  } @else if $type == matador {
    color: red;
  } @else if $type == monster {
    color: green;
  } @else {
    color: black;
  }
}
```

`output`

```css
p { color: green; }
```

### @for

- 在限制的范围内重复输出格式，每次按要求（变量的值）对输出结果做出变动
- `@for $var from <start> through <end>`
  - 条件范围包含 `<start>` 与 `<end>` 的值
- `@for $var from <start> to <end>`
  - 条件范围只包含 `<start>` 的值不包含 `<end>` 的值
- $var 可以是任何变量，比如 $i
- `<start>` 和 `<end>` 必须是整数值

```scss
@for $i from 1 through 3 {
  .item-#{$i} { width: 2em * $i; }
}
```

`output`

```css
.item-1 {
  width: 2em; }
.item-2 {
  width: 4em; }
.item-3 {
  width: 6em; }
```

### @each

- `@each $var in <list>`
- `$var` 可以是任何变量名
- `<list>` 是一连串的值，也就是值列表
- `@each` 将变量 `$var` 作用于值列表中的每一个项目，然后输出结果

```scss
@each $animal in puma, sea-slug, egret, salamander {
  .#{$animal}-icon {
    background-image: url('/images/#{$animal}.png');
  }
}
```

`output`

```css
.puma-icon {
  background-image: url('/images/puma.png');
}
.sea-slug-icon {
  background-image: url('/images/sea-slug.png');
}
.egret-icon {
  background-image: url('/images/egret.png');
}
.salamander-icon {
  background-image: url('/images/salamander.png');
}
```

#### 多重赋值

- 每次变量都进行类似于解构赋值的操作

```scss
@each $animal, $color, $cursor in (puma, black, default),
                                  (sea-slug, blue, pointer),
                                  (egret, white, move) {
  .#{$animal}-icon {
    background-image: url('/images/#{$animal}.png');
    border: 2px solid $color;
    cursor: $cursor;
  }
}
```

`output`

```css
.puma-icon {
  background-image: url('/images/puma.png');
  border: 2px solid black;
  cursor: default;
}
.sea-slug-icon {
  background-image: url('/images/sea-slug.png');
  border: 2px solid blue;
  cursor: pointer;
}
.egret-icon {
  background-image: url('/images/egret.png');
  border: 2px solid white;
  cursor: move;
}
```

- 由于maps类型也能看成list, 所以也适用多重赋值

```scss
@each $header, $size in (h1: 2em, h2: 1.5em, h3: 1.2em) {
  #{$header} {
    font-size: $size;
  }
}
```

`output`

```css
h1 {
  font-size: 2em;
}
h2 {
  font-size: 1.5em;
}
h3 {
  font-size: 1.2em;
}
```

### @while

- 重复输出格式直到表达式返回结果为 false

```scss
$i: 6;
@while $i > 0 {
  .item-#{$i} { width: 2em * $i; }
  $i: $i - 2;
}
```

`output`

```css
.item-6 {
  width: 12em;
}

.item-4 {
  width: 8em;
}

.item-2 {
  width: 4em;
}
```

## 混合指令

- 用于定义可重复使用的样式，避免了使用无语意的 class
- 混合指令可以包含所有的 CSS 规则，绝大部分 Sass 规则，甚至通过参数功能引入变量，输出多样化的样式

### 定义混合指令 @mixin

```scss
@mixin large-text {
  font: {
    family: Arial;
    size: 20px;
    weight: bold;
  }
  color: #ff0000;
}

@mixin clearfix {
  display: inline-block;
  &:after {
    content: ".";
    display: block;
    height: 0;
    clear: both;
    visibility: hidden;
  }
  * html & { height: 1px }
}
```

### 引用混合指令 @include

```scss
.page-title {
  @include large-text; // 或者 @include large-text();
  padding: 4px;
  margin-top: 10px;
}
```

`output`

```css
.page-title {
  font-family: Arial;
  font-size: 20px;
  font-weight: bold;
  color: #ff0000;
  padding: 4px;
  margin-top: 10px;
}
```

- 也可以在最外层引用混合样式，不会直接定义属性，也不可以使用父选择器。

```scss
@mixin silly-links {
  a {
    color: blue;
    background-color: red;
  }
}
@include silly-links;
```

`output`

```css
a {
  color: blue;
  background-color: red;
}
```

- 混合样式中也可以包含其他混合样式

```scss
@mixin compound {
  @include highlighted-background;
  @include header-text;
}
@mixin highlighted-background { background-color: #fc0; }
@mixin header-text { font-size: 20px; }
```

- 混合样式中应该只定义后代选择器，这样可以安全的导入到文件的任何位置
- %占位符定义属性样式，@mixin定义选择器样式

### 参数

- 参数用于给混合指令中的样式设定变量，并且赋值使用
- 在定义混合指令的时候，按照变量的格式，通过逗号分隔，将参数写进圆括号里
- 引用指令时，按照参数的顺序，再将所赋的值对应写进括号
- 也可以给参数设置默认值

```scss
@mixin sexy-border($color, $width: 2in) {
  border: {
    color: $color;
    width: $width;
    style: dashed;
  }
}
p { @include sexy-border(blue, 1in); }
h1 { @include sexy-border(blue); }
```

`output`

```css
p {
  border-color: blue;
  border-width: 1in;
  border-style: dashed;
}

h1 {
  border-color: blue;
  border-width: 2in;
  border-style: dashed;
}
```

#### 关键词参数

- 关键词参数可以打乱顺序使用，如果使用默认值也可以省缺
- 参数名被视为变量名，下划线、短横线可以互换使用

```scss
@mixin sexy-border($color, $width: 2in) {
  border: {
    color: $color;
    width: $width;
    style: dashed;
  }
}

p { @include sexy-border($color: blue, $width: 1in); }
h1 { @include sexy-border($color: blue); }
```

#### 参数变量

- 不能确定混合指令需要使用多少个参数
- 使用参数变量 … 声明（写在参数的最后方）告诉 Sass 将这些参数视为值列表处理

```scss
@mixin box-shadow($shadows...) {
  -moz-box-shadow: $shadows;
  -webkit-box-shadow: $shadows;
  box-shadow: $shadows;
}

.shadows {
  @include box-shadow(0px 4px 5px #666, 2px 6px 10px #999);
}
```

- 参数变量也可以用在引用混合指令的时候, 将一串值列表中的值逐条作为参数引用
- 当参数变量的值是一串值列表时，直接传入会报错，只能匹配到第一个数据

```scss
@mixin colors($text, $background, $border) {
  color: $text;
  background-color: $background;
  border-color: $border;
}
$values: #ff0000, #00ff00, #0000ff;
.primary {
  @include colors($values...);
}
```

- 使用参数变量可以向被包裹的mixin传递参数和关键词参数，而不用去改mixin的参数名

```scss
@mixin wrapped-stylish-mixin($args...) {
  font-weight: bold;
  @include stylish-mixin($args...);
}
.stylish {
  // $width 参数将会传递给 stylish-mixin 作为关键词
  @include wrapped-stylish-mixin(#00ff00, $width: 100px);
}
```

### 向混合样式中导入内容

- 在引用混合样式的时候，可以先将一段代码导入到混合指令中，然后再输出混合样式，额外导入的部分将出现在 @content 标志的地方

```scss
@mixin apply-to-ie6-only {
  * html {
    @content;
  }
}
@include apply-to-ie6-only {
  #logo {
    background-image: url(/logo.gif);
  }
}
```

`output`

```css
* html #logo {
  background-image: url(/logo.gif);
}
```

- `@mixin`可以简写为`=`, `@include`可以简写为`+` (只适合sass语法格式)
- 当`@content`在指令中出现过多次或者出现在循环中时，额外的代码将被导入到每一个地方

```sass
=apply-to-ie6-only
  * html
    @content

+apply-to-ie6-only
  #logo
    background-image: url(/logo.gif)
```

- 传递给mixin的内容块在定义该块的范围内求值，而不是在mixin的范围内求值

```scss
@mixin colors($color: blue) {
  background-color: $color;
  @content;
  border-color: $color;
}
.colors {
  // 如果此处没有定义，则在全局变量中查找
  $color: white;
  @include colors {
    color: $color;
  }
}
```

`output`

```css
.colors {
  background-color: blue;
  color: white;
  border-color: blue;
}
```

### 函数指令 @function

- Sass 支持自定义函数，并能在任何属性值或 Sass script 中使用
- 可以传递若干个全局变量给函数作为参数。一个函数可以含有多条语句，需要调用 @return 输出结果
- 和mixin一样支持参数变量
- 建议在自定义函数前添加前缀避免命名冲突，清楚表明这不是 Sass 或者 CSS 的自带功能

```scss
$grid-width: 40px;
$gutter-width: 10px;

@function grid-width($n) {
  @return $n * $grid-width + ($n - 1) * $gutter-width;
}

#sidebar { width: grid-width(5); }
// 也可以使用关键词参数
#sidebar { width: grid-width($n: 5); }
```

`output`

```css
#sidebar { width: 240px; }
```

#### @function 和 @each 配合使用

```scss
@function grid-width($args...) {
  $x: 0px;
  @each $var in $args {
    $x: $x + $var
  }

  @return $x
}

#sidebar {
  width: grid-width1(1,2,3)
}
```

`output`

```css
#sidebar { width: 6px; }
```
